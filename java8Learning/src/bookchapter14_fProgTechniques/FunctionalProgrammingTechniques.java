package bookchapter14_fProgTechniques;

import java.util.function.DoubleUnaryOperator;
import java.util.function.Supplier;

/**
 * Created by rowland-hall on 22/07/16
 *
 * TODO: not looked at some of the functional programming theoretical stuff in this Chapeter, from p400 onwards.
 */
public class FunctionalProgrammingTechniques
{
    static void p( Object o)
    {
        System.out.println(o);
    }

    public static void main( String[] args )
    {
        /*
        Currying: lets look at a linear converter example that used a baseline with a multiplication factor,
        e.g.
         i) for degC to degF formula = y = (x*9)/5 +32
         ii) for gbp to usd: formula = y = x * 1.5 +0
        */

        //i) use an un-curried converter:

        double _30DegreesCinFar = doConversion( 30d, (9d/5d), 32);
        p( _30DegreesCinFar );

        //or you can curry out the thing, as so:
        DoubleUnaryOperator degCToDegFConverter = getCurriedConverter( (9d/5d), 32 );
        DoubleUnaryOperator gbpToUsd = getCurriedConverter( 1.5, 0 );

        p( "100 deg c in F=" + degCToDegFConverter.applyAsDouble( 100d ));
        p( "100 gbp in usd=" + gbpToUsd.applyAsDouble( 100d ) );

        //NOTE: the advantage of the curried out way is that we have only defined the maths once, it is the factors that vary

        //LAZY LIST EXAMPLE, p ~396 ish...
        //NOTE the daft example of the double read stream on p.394, which leads to idea of creating a lazy list to produce an
        //endless list of prime numbers, basically a list where we use a function to generate the next item:

        //PRINT ALL NUMBERS FROM 1 to 100:

        LazyList<Integer> intList = continuousListOfIntegersStartingFrom( 1 );

        //basically what we have here is a List of integers where only the first element exists at start up, next ones are generated by
        //the given function:

        p(intList.head());
        for( int i =0; i<100; i++ )
        {
            intList = intList.tail();
            p(intList.head());
        }

    }

    static double doConversion( double x, double f, int b )
    {
        return (x * f) + b;
    }

    /*
    this thing be a 'higher order function, i.e. one which either i) takes a function as a parameter or ii)
    returns another function.
     */
    static DoubleUnaryOperator getCurriedConverter( double factor, double baseline )
    {
        return (x) -> (factor *x ) + baseline;
    }

    //NOTE how this class uses a function to generate the next elements in the list
    static class LazyList<T>
    {
        private T head;

        private Supplier<LazyList<T>> tail;


        public LazyList( T head, Supplier<LazyList<T>> tail )
        {
            this.head = head;
            this.tail = tail;
        }

        public T head()
        {
            return head;
        }

        public LazyList tail()
        {
            return tail.get();
        }
    }

    //NOTE how we create a supplier to give to the LazyList that will cause it to be a list of integers from n upwards:
    static LazyList<Integer> continuousListOfIntegersStartingFrom( int n )
    {
        Supplier<LazyList<Integer>> supplier = () -> continuousListOfIntegersStartingFrom( n+1 );

        return new LazyList<>( n, supplier );
    }

    //NOTE how we create a supplier to give to the LazyList that will cause it to be a list of primes from n upwards:
    static LazyList<Integer> continuousListOfPrimeNumberStartingFrom( int n )
    {
        Supplier<LazyList<Integer>> supplier = () -> continuousListOfIntegersStartingFrom( n+1 );

        return new LazyList<>( n, supplier );
    }
}
